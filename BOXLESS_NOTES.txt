Equation:
    rhs: Fn(State) -> [f64; N]

Event:
    callback: Fn(State) -> Output
    stream: Vec<Fn(Output)>
    filter: Vec<Fn(State) -> bool>

IC:
    [f64; N] 
    or
    Fn(f64) -> [f64; N]
    or
    (Fn(f64) -> [f64; N], Fn(f64) -> [f64; N])

Loc:
    Detection:
        Fn(State) -> f64 (+ differentiable in time)
        Fn(State) -> bool

Solver:
    events: Vec<Fn(State)>
    loc_events: Vec<(Loc, Fn(State))>



Tasks:
  Traits
    Differentiable
      .eval(arg)
      [i].eval(arg)
      Into<Differentiable> for
        Fn(f64) -> [f64; N]
        [f64; N]
     
    StateFnMut<Output>, methods are generic over State
      .eval
      .eval_at
      .eval_prev

  Static collections of trait objects:
    .push
    .pop
    call a method for each






Distinction between MutState and State events
State events:
  subdivision can be applied
  does not modify integration steps

MutState:
  subdivision cannot be applied
  adds additional step (before/after)

It makes sense to conditionally call an event from other event:

.on_step(event!(... request_event("stop_integration")))
.on_request(Event::stop_integration())

.on_step(event!(|t| (t > 0).then(|| stop_integration.set(true))))
.on_step(Event::stop_itegration().filter(|| stop_integration.get()))





